name: CI

on:
  pull_request:
  workflow_dispatch:
    inputs:
      deploy:
        description: "Deploy to production (opt-in; main only)"
        type: boolean
        required: false
        default: false
  push:
    branches:
      - main

# Least-privilege: CI jobs only need to read repository contents.
permissions:
  contents: read

jobs:
  validate-deploy-connectivity:
    runs-on: ubuntu-latest
    # Safety gate: deploy preflight runs only for main deploy paths.
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (inputs.deploy == true || github.event.inputs.deploy == 'true'))
    steps:
      - name: Validate deploy host is public-reachable
        shell: bash
        env:
          HOST: ${{ secrets.HOST }}
        run: |
          set -euo pipefail

          if [[ -z "${HOST:-}" ]]; then
            echo "::error::Missing required secret: HOST."
            exit 1
          fi

          # 防呆：GitHub-hosted runner 无法直连内网/回环地址；如果误把 192.168/10/172.16-31 填进 secrets.HOST，
          # 会导致每次 deploy 白跑一遍 CI 后才失败。
          if [[ "$HOST" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
            IFS='.' read -r o1 o2 o3 o4 <<<"$HOST"

            for o in "$o1" "$o2" "$o3" "$o4"; do
              if ! [[ "$o" =~ ^[0-9]+$ ]] || (( o < 0 || o > 255 )); then
                exit 0
              fi
            done

            if (( o1 == 10 )) || (( o1 == 127 )) || (( o1 == 0 )) || (( o1 == 169 && o2 == 254 )) || (( o1 == 192 && o2 == 168 )) || (( o1 == 172 && o2 >= 16 && o2 <= 31 )); then
              echo "::error::secrets.HOST 看起来是内网/回环地址；GitHub-hosted runner 无法直连。请改为公网域名/IP，或改用 self-hosted runner / VPN。"
              exit 1
            fi
          else
            # HOST 是域名时：尽量在 runner 侧解析 IPv4，避免误把内网地址写进公共 DNS。
            # 不回显解析结果（避免泄露），仅在“全部解析到内网/保留地址”时失败。
            if command -v getent >/dev/null 2>&1; then
              resolved_ips="$(getent ahostsv4 "$HOST" 2>/dev/null | awk '{print $1}' | sort -u || true)"
              if [[ -n "${resolved_ips//[[:space:]]/}" ]]; then
                public_found=0
                private_only=1
                while IFS= read -r ip; do
                  if [[ ! "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                    continue
                  fi
                  IFS='.' read -r o1 o2 o3 o4 <<<"$ip"
                  if (( o1 == 10 )) || (( o1 == 127 )) || (( o1 == 0 )) || (( o1 == 169 && o2 == 254 )) || (( o1 == 192 && o2 == 168 )) || (( o1 == 172 && o2 >= 16 && o2 <= 31 )); then
                    continue
                  fi
                  public_found=1
                  private_only=0
                done <<<"$resolved_ips"

                if (( private_only == 1 && public_found == 0 )); then
                  echo "::error::secrets.HOST 在 runner 侧解析到的 IPv4 全部是内网/保留地址；GitHub-hosted runner 无法直连。请改为公网域名/IP，或改用 self-hosted runner / VPN。"
                  exit 1
                fi
              fi
            fi
          fi

      - name: Validate deploy host reachability (nc)
        shell: bash
        env:
          HOST: ${{ secrets.HOST }}
          PORT: ${{ secrets.PORT }}
        run: |
          set -euo pipefail

          if [[ -z "${HOST:-}" || -z "${PORT:-}" ]]; then
            echo "::error::Missing required secrets: HOST/PORT."
            exit 1
          fi

          # Do not print host/port. Retry to avoid transient network flakiness.
          attempts=3
          for ((i=1; i<=attempts; i++)); do
            # Force IPv4 to avoid accidental IPv6 routing/DNS surprises.
            if nc -4 -z -w 5 "$HOST" "$PORT" >/dev/null 2>&1; then
              exit 0
            fi
            sleep 2
          done

          echo "::error::Deploy preflight failed: cannot reach SSH port from runner. Check firewall/security group, port forwarding, and DNS."
          exit 1

  backend-ci:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          enable-cache: true
          cache-dependency-glob: |
            backend/pyproject.toml
            backend/uv.lock

      - name: Install dependencies
        run: uv sync --frozen

      - name: Run tests
        run: uv run pytest -q

  web-ci:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    env:
      NEXT_PUBLIC_API_BASE_URL: http://localhost:8000
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Build
        run: npm run build

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: E2E tests
        run: npm run test:e2e

  android-ci:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: android
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android SDK packages
        run: |
          yes | sdkmanager --licenses
          sdkmanager "platform-tools" "platforms;android-34" "build-tools;34.0.0"

      - name: Setup Gradle cache
        uses: gradle/actions/setup-gradle@v3

      - name: Ensure gradlew is executable
        run: chmod +x ./gradlew

      - name: Unit tests
        run: ./gradlew test

  deploy:
    runs-on: ubuntu-latest
    # Safety gate: deploy only on pushes to main, or opt-in manual runs on main.
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (inputs.deploy == true || github.event.inputs.deploy == 'true'))
    needs:
      - validate-deploy-connectivity
      - backend-ci
      - web-ci
      - android-ci
    concurrency:
      group: deploy-main
      cancel-in-progress: false
    timeout-minutes: 30
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate deploy host is public-reachable
        shell: bash
        env:
          HOST: ${{ secrets.HOST }}
        run: |
          set -euo pipefail

          if [[ -z "${HOST:-}" ]]; then
            echo "::error::Missing required secret: HOST."
            exit 1
          fi

          if [[ "$HOST" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
            IFS='.' read -r o1 o2 o3 o4 <<<"$HOST"

            for o in "$o1" "$o2" "$o3" "$o4"; do
              if ! [[ "$o" =~ ^[0-9]+$ ]] || (( o < 0 || o > 255 )); then
                exit 0
              fi
            done

            if (( o1 == 10 )) || (( o1 == 127 )) || (( o1 == 0 )) || (( o1 == 169 && o2 == 254 )) || (( o1 == 192 && o2 == 168 )) || (( o1 == 172 && o2 >= 16 && o2 <= 31 )); then
              echo "::error::secrets.HOST 看起来是内网/回环地址；GitHub-hosted runner 无法直连。请改为公网域名/IP，或改用 self-hosted runner / VPN。"
              exit 1
            fi
          else
            if command -v getent >/dev/null 2>&1; then
              resolved_ips="$(getent ahostsv4 "$HOST" 2>/dev/null | awk '{print $1}' | sort -u || true)"
              if [[ -n "${resolved_ips//[[:space:]]/}" ]]; then
                public_found=0
                private_only=1
                while IFS= read -r ip; do
                  if [[ ! "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                    continue
                  fi
                  IFS='.' read -r o1 o2 o3 o4 <<<"$ip"
                  if (( o1 == 10 )) || (( o1 == 127 )) || (( o1 == 0 )) || (( o1 == 169 && o2 == 254 )) || (( o1 == 192 && o2 == 168 )) || (( o1 == 172 && o2 >= 16 && o2 <= 31 )); then
                    continue
                  fi
                  public_found=1
                  private_only=0
                done <<<"$resolved_ips"

                if (( private_only == 1 && public_found == 0 )); then
                  echo "::error::secrets.HOST 在 runner 侧解析到的 IPv4 全部是内网/保留地址；GitHub-hosted runner 无法直连。请改为公网域名/IP，或改用 self-hosted runner / VPN。"
                  exit 1
                fi
              fi
            fi
          fi

      - name: Setup SSH (key + known_hosts)
        shell: bash
        env:
          SSH_PRIVATE_KEY: ${{ secrets.CI || secrets.SSH_PRIVATE_KEY }}
          KNOWN_HOSTS: ${{ secrets.KNOWN_HOSTS }}
        run: |
          set -euo pipefail

          # Use pinned host keys; keep StrictHostKeyChecking enabled.
          # Prefer secret-provided known_hosts; fall back to repo-pinned `.github/known_hosts`.
          HOST='${{ secrets.HOST }}'
          PORT='${{ secrets.PORT }}'

          if [[ -z "${SSH_PRIVATE_KEY}" ]]; then
            echo "Missing required secret: CI (or SSH_PRIVATE_KEY) (SSH private key)."
            exit 1
          fi

          install -d -m 700 ~/.ssh

          # Write secrets without printing them; normalize CRLF just in case.
          printf '%s\n' "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_ci
          chmod 600 ~/.ssh/id_ci

          # Print a non-sensitive fingerprint to help debug "Permission denied (publickey)" issues.
          # (This does not reveal the private key; it only shows the public-key fingerprint.)
          if ssh-keygen -lf ~/.ssh/id_ci >/dev/null 2>&1; then
            echo "Deploy SSH key fingerprint (for server authorized_keys matching):"
            ssh-keygen -lf ~/.ssh/id_ci || true
          else
            echo "::warning::Unable to parse deploy SSH private key (invalid format or encrypted key)."
          fi

          tmp_known_hosts="$(mktemp)"
          : > "$tmp_known_hosts"

          # Always include repo-pinned known_hosts when present, even if a secret is provided.
          # This reduces breakage when secrets.HOST switches between domain/IP aliases.
          if [[ -f ".github/known_hosts" ]]; then
            tr -d '\r' < .github/known_hosts >> "$tmp_known_hosts"
            printf '\n' >> "$tmp_known_hosts"
          fi

          if [[ -n "${KNOWN_HOSTS//[[:space:]]/}" ]]; then
            printf '%s\n' "$KNOWN_HOSTS" | tr -d '\r' >> "$tmp_known_hosts"
            printf '\n' >> "$tmp_known_hosts"
          fi

          if ! awk 'NF {print}' "$tmp_known_hosts" > ~/.ssh/known_hosts; then
            echo "::error::Failed to write ~/.ssh/known_hosts."
            rm -f "$tmp_known_hosts" || true
            exit 1
          fi
          rm -f "$tmp_known_hosts" || true

          if [[ ! -s ~/.ssh/known_hosts ]]; then
            echo "::error::Missing pinned known_hosts. Provide secrets.KNOWN_HOSTS or commit .github/known_hosts."
            exit 1
          fi
          chmod 600 ~/.ssh/known_hosts

          # Validate pinned known_hosts has a usable entry for the deploy target.
          # Use ssh-keygen to support both plain and hashed hostnames (e.g. ssh-keyscan -H output).
          if ! command -v ssh-keygen >/dev/null 2>&1; then
            echo "::error::Missing required tool: ssh-keygen."
            exit 1
          fi

          if ! ssh-keygen -F "[$HOST]:$PORT" -f ~/.ssh/known_hosts >/dev/null 2>&1 && ! ssh-keygen -F "$HOST" -f ~/.ssh/known_hosts >/dev/null 2>&1; then
            # Auto-alias (safe):
            # If repo-pinned `.github/known_hosts` exists, use its key to create an alias entry for secrets.HOST.
            # This is commonly needed when HOST switches between domain / public IP / internal IP.
            repo_host_key="$(
              awk '
                NF >= 3 && $1 !~ /^#/ && $1 !~ /^@/ && $2 == "ssh-ed25519" { print $2, $3; exit }
                NF >= 3 && $1 !~ /^#/ && $1 !~ /^@/ { print $2, $3; exit }
              ' .github/known_hosts 2>/dev/null || true
            )"
            if [[ -n "${repo_host_key//[[:space:]]/}" ]]; then
              printf '%s %s\n' "$HOST" "$repo_host_key" >> ~/.ssh/known_hosts
              if [[ "$PORT" != "22" ]]; then
                printf '[%s]:%s %s\n' "$HOST" "$PORT" "$repo_host_key" >> ~/.ssh/known_hosts
              fi
            fi
          fi

          if ! ssh-keygen -F "[$HOST]:$PORT" -f ~/.ssh/known_hosts >/dev/null 2>&1 && ! ssh-keygen -F "$HOST" -f ~/.ssh/known_hosts >/dev/null 2>&1; then
            echo "::error::Pinned known_hosts missing entry for deploy target (secrets.HOST / secrets.PORT). Update secrets.KNOWN_HOSTS or .github/known_hosts."
            echo "::error::Debug: pinned_known_hosts_lines=$(wc -l < ~/.ssh/known_hosts | tr -d ' ')"
            exit 1
          fi

          # For non-22 ports, OpenSSH expects an additional [host]:port form.
          if [[ "$PORT" != "22" ]]; then
            if ! ssh-keygen -F "[$HOST]:$PORT" -f ~/.ssh/known_hosts >/dev/null 2>&1; then
              # Derive keytype+key from the first matching entry and append bracket form.
              host_key="$(ssh-keygen -F "$HOST" -f ~/.ssh/known_hosts | awk '
                NF >= 3 && $1 !~ /^#/ {
                  if ($1 ~ /^@/) { print $3, $4; exit }
                  print $2, $3; exit
                }
              ')"
              if [[ -z "${host_key//[[:space:]]/}" ]]; then
                echo "::error::Pinned known_hosts is present but missing a usable host key line for the deploy target."
                exit 1
              fi
              printf '[%s]:%s %s\n' "$HOST" "$PORT" "$host_key" >> ~/.ssh/known_hosts
            fi
          fi

          # Print pinned host key fingerprint for debugging (non-sensitive; does not reveal hostname/IP).
          # This helps verify the runner is pinning the correct server host key.
          pinned_host_key="$(
            ssh-keygen -F "[$HOST]:$PORT" -f ~/.ssh/known_hosts 2>/dev/null | awk '
              NF >= 3 && $1 !~ /^#/ {
                if ($1 ~ /^@/) { print $3, $4; exit }
                print $2, $3; exit
              }
            ' || true
          )"
          if [[ -z "${pinned_host_key//[[:space:]]/}" ]]; then
            pinned_host_key="$(
              ssh-keygen -F "$HOST" -f ~/.ssh/known_hosts 2>/dev/null | awk '
                NF >= 3 && $1 !~ /^#/ {
                  if ($1 ~ /^@/) { print $3, $4; exit }
                  print $2, $3; exit
                }
              ' || true
            )"
          fi
          if [[ -n "${pinned_host_key//[[:space:]]/}" ]]; then
            tmp_host_key_file="$(mktemp)"
            printf '%s\n' "$pinned_host_key" > "$tmp_host_key_file"
            echo "Pinned host key fingerprint (compare with server /etc/ssh/ssh_host_*_key.pub):"
            ssh-keygen -lf "$tmp_host_key_file" || true
            rm -f "$tmp_host_key_file" || true
          else
            echo "::warning::Unable to extract pinned host key fingerprint from known_hosts."
          fi

      - name: Deploy (remote)
        shell: bash
        env:
          HOST: ${{ secrets.HOST }}
          PORT: ${{ secrets.PORT }}
          SSH_USER: ${{ secrets.USER }}
          REPO_DIR: /root/dockers/1wayfarer
          TARGET_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          if [[ -z "${HOST:-}" || -z "${PORT:-}" || -z "${SSH_USER:-}" ]]; then
            echo "Missing required deploy secrets: HOST/PORT/USER."
            exit 1
          fi

          SSH_ERR_FILE="$(mktemp)"

          if ! ssh -4 \
            -i ~/.ssh/id_ci \
            -p "$PORT" \
            -o BatchMode=yes \
            -o IdentitiesOnly=yes \
            -o StrictHostKeyChecking=yes \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "$SSH_USER@$HOST" \
            "REPO_DIR='$REPO_DIR' TARGET_SHA='$TARGET_SHA' bash -s" <<'EOF' 2>"$SSH_ERR_FILE"
          set -euo pipefail

          LOCK_WAIT_SECONDS=600
          LOCK_FILE="/tmp/wayfarer-deploy.lock"
          LOCK_DIR="/tmp/wayfarer-deploy.lockdir"

          acquire_lock() {
            if command -v flock >/dev/null 2>&1; then
              # Keep FD 9 open for the duration of the script.
              exec 9>"$LOCK_FILE"
              flock -w "$LOCK_WAIT_SECONDS" 9
              return 0
            fi

            # Fallback if flock is not installed.
            for ((i=0; i<LOCK_WAIT_SECONDS; i++)); do
              if mkdir "$LOCK_DIR" 2>/dev/null; then
                trap 'rmdir "$LOCK_DIR" 2>/dev/null || true' EXIT
                return 0
              fi
              sleep 1
            done

            echo "Failed to acquire deploy lock within ${LOCK_WAIT_SECONDS}s."
            return 1
          }

          require_cmd() {
            local cmd="$1"
            if ! command -v "$cmd" >/dev/null 2>&1; then
              echo "Missing required tool: $cmd"
              exit 1
            fi
          }

          require_cmd git
          require_cmd docker
          require_cmd curl
          require_cmd grep
          require_cmd tail
          require_cmd tr

          if ! docker compose version >/dev/null 2>&1; then
            echo "Missing required tool: docker compose"
            exit 1
          fi

          # Faster and more reliable builds.
          export DOCKER_BUILDKIT=1
          export COMPOSE_DOCKER_CLI_BUILD=1

          if [[ -z "${REPO_DIR:-}" || -z "${TARGET_SHA:-}" ]]; then
            echo "Internal error: REPO_DIR/TARGET_SHA not set."
            exit 1
          fi

          acquire_lock

          if [[ ! -d "$REPO_DIR" ]]; then
            echo "Repo directory does not exist: $REPO_DIR"
            exit 1
          fi

          cd "$REPO_DIR"

          if [[ ! -d .git ]]; then
            echo "Not a git repository: $REPO_DIR"
            exit 1
          fi
          if [[ ! -f .env ]]; then
            echo "Missing .env in $REPO_DIR (deploy requires env_file)."
            exit 1
          fi

          require_env_nonempty() {
            local key="$1"
            local line val

            line="$(grep -E "^${key}=" .env | tail -n 1 || true)"
            if [[ -z "$line" ]]; then
              echo "Missing required env var in .env: $key"
              exit 1
            fi

            val="${line#*=}"
            val="$(printf '%s' "$val" | tr -d '\r')"

            if [[ "$val" =~ ^\".*\"$ ]]; then
              val="${val:1:${#val}-2}"
            elif [[ "$val" =~ ^\'.*\'$ ]]; then
              val="${val:1:${#val}-2}"
            fi

            # Reject empty or whitespace-only values without ever printing them.
            if [[ -z "${val//[[:space:]]/}" ]]; then
              echo "Empty required env var in .env: $key"
              exit 1
            fi
          }

          require_env_nonempty WAYFARER_JWT_SIGNING_KEYS_JSON
          require_env_nonempty WAYFARER_JWT_KID_CURRENT
          require_env_nonempty NEXT_PUBLIC_API_BASE_URL

          # Deploy what was tested: only proceed if this workflow SHA is still the tip of origin/main.
          git fetch --quiet origin main
          origin_tip="$(git rev-parse origin/main)"
          if [[ "$origin_tip" != "$TARGET_SHA" ]]; then
            echo "Stale deploy: workflow SHA is not origin/main tip; skipping."
            exit 0
          fi

            if [[ -n "$(git status --porcelain)" ]]; then
              echo "Repo has local modifications; creating safety stash before deploy."
              # Stash local changes so checkout cannot fail; keep .env in place for docker compose.
              if ! git stash push -u -m "ci: preflight stash before deploy $TARGET_SHA" >/dev/null 2>&1; then
                echo "Failed to create safety stash; refusing to deploy."
                exit 1
              fi
            fi

           # Capture the currently deployed revision before switching to TARGET_SHA.
           PREV_SHA="$(git rev-parse HEAD)"
           if ! git cat-file -e "${PREV_SHA}^{commit}" >/dev/null 2>&1; then
             echo "Failed to resolve PREV_SHA; refusing to deploy."
             exit 1
           fi

           git checkout --detach --quiet "$TARGET_SHA"
           if [[ "$(git rev-parse HEAD)" != "$TARGET_SHA" ]]; then
             echo "Checkout mismatch; refusing to deploy."
             exit 1
           fi

           docker compose up -d --build

          wait_http_ok() {
            local url="$1"
            local name="$2"
            local attempts=30
            local sleep_seconds=2
            local last_http_code="000"

            for ((i=1; i<=attempts; i++)); do
              # Keep the loop quiet; on failure we emit a one-shot diagnostic below.
              last_http_code="$(curl -sS -o /dev/null -w '%{http_code}' --max-time 2 "$url" 2>/dev/null || echo '000')"
              if [[ "$last_http_code" =~ ^[23][0-9][0-9]$ ]]; then
                echo "$name is healthy (http_code=$last_http_code)."
                return 0
              fi
              sleep "$sleep_seconds"
            done

            echo "$name failed health check after ${attempts} attempts (last_http_code=$last_http_code)."
            echo "Health probe detail (one shot): $url"
            curl -sS -o /dev/null -w "http_code=%{http_code} time_total=%{time_total}\n" --max-time 5 "$url" || true
            return 1
           }

           deploy_ok=1
           if ! wait_http_ok "http://127.0.0.1:18000/readyz" "backend /readyz"; then
             deploy_ok=0
           fi
           if ! wait_http_ok "http://127.0.0.1:13000/" "web /"; then
             deploy_ok=0
           fi

           if [[ "$deploy_ok" -eq 1 ]]; then
             exit 0
           fi

           echo "Deploy failed health gate for TARGET_SHA=$TARGET_SHA; attempting rollback to PREV_SHA=$PREV_SHA."

           rollback_ok=0
           if git checkout --detach --quiet "$PREV_SHA" && docker compose up -d --build; then
             rollback_health_ok=1
             if ! wait_http_ok "http://127.0.0.1:18000/readyz" "backend /readyz (post-rollback)"; then
               rollback_health_ok=0
             fi
             if ! wait_http_ok "http://127.0.0.1:13000/" "web / (post-rollback)"; then
               rollback_health_ok=0
             fi
             if [[ "$rollback_health_ok" -eq 1 ]]; then
               rollback_ok=1
             fi
           fi

           echo "Diagnostics (post-rollback attempt): docker compose images"
           docker compose images || true
           echo "Diagnostics (post-rollback attempt): docker compose ps"
           docker compose ps || true
           echo "Diagnostics (post-rollback attempt): docker compose logs --tail 200 wayfarer-backend wayfarer-web"
           docker compose logs --tail 200 wayfarer-backend wayfarer-web || true

           if [[ "$rollback_ok" -eq 1 ]]; then
             echo "Rollback succeeded and health restored (PREV_SHA=$PREV_SHA)."
           else
             echo "Rollback did not restore health (PREV_SHA=$PREV_SHA)."
           fi

            # Exit non-zero to fail the job even if rollback succeeded.
            exit 1
          EOF
            then
              python - "$SSH_ERR_FILE" <<'PY'
          import os
          import re
          import sys

          path = sys.argv[1]
          try:
              data = open(path, 'r', errors='replace').read().splitlines()
          except FileNotFoundError:
              data = []

          host = os.environ.get('HOST', '')
          user = os.environ.get('SSH_USER', '')
          port = os.environ.get('PORT', '')

          # Keep only likely-useful SSH error lines; fallback to first 30 lines.
          patterns = [
              r'Host key verification failed',
              r'REMOTE HOST IDENTIFICATION HAS CHANGED',
              r'Permission denied',
              r'Authentication failed',
              r'Too many authentication failures',
              r'kex_exchange_identification',
              r'Connection timed out',
              r'Connection refused',
              r'No route to host',
              r'Network is unreachable',
              r'Could not resolve hostname',
              r'Name or service not known',
              r'Temporary failure in name resolution',
              r'WARNING',
          ]

          sel = [ln for ln in data if any(re.search(p, ln, re.I) for p in patterns)]
          if not sel:
              sel = data[:30]

          text = "\n".join(sel)

          # Redact host/user/port without printing raw values.
          if host and port:
              text = text.replace(f'[{host}]:{port}', '<HOST>:<PORT>')
          if user and host:
              text = text.replace(f'{user}@{host}', '<SSH_USER>@<HOST>')
          if user:
              text = text.replace(user, '<SSH_USER>')
          if host:
              text = text.replace(host, '<HOST>')
          if port:
              text = text.replace(f' port {port}', ' port <PORT>')
              text = text.replace(f':{port}', ':<PORT>')

          print('SSH remote deploy failed. Sanitized stderr (excerpt):')
          print(text)
          PY

              # If this looks like an auth failure, run a second SSH attempt with -vv to show which key is offered.
              if grep -qiE 'permission denied|authentication failed|too many authentication failures|no supported authentication methods' "$SSH_ERR_FILE"; then
                SSH_DEBUG_FILE="$(mktemp)"
                ssh -4 -vv \
                  -i ~/.ssh/id_ci \
                  -p "$PORT" \
                  -o BatchMode=yes \
                  -o IdentitiesOnly=yes \
                  -o StrictHostKeyChecking=yes \
                  -o UserKnownHostsFile=~/.ssh/known_hosts \
                  -o PreferredAuthentications=publickey \
                  -o PasswordAuthentication=no \
                  -o KbdInteractiveAuthentication=no \
                  "$SSH_USER@$HOST" \
                  "true" 2>"$SSH_DEBUG_FILE" || true

                python - "$SSH_DEBUG_FILE" <<'PY'
          import os
          import re
          import sys

          path = sys.argv[1]
          try:
              data = open(path, 'r', errors='replace').read().splitlines()
          except FileNotFoundError:
              data = []

          host = os.environ.get('HOST', '')
          user = os.environ.get('SSH_USER', '')
          port = os.environ.get('PORT', '')

          patterns = [
              r'Offering public key',
              r'Server accepts key',
              r'sign_and_send_pubkey',
              r'Authentications that can continue',
              r'Next authentication method',
              r'No more authentication methods',
              r'Permission denied',
              r'Load key',
              r'identity file',
              r'Host key verification failed',
              r'REMOTE HOST IDENTIFICATION HAS CHANGED',
              r'Could not resolve hostname',
              r'Connection timed out',
              r'Connection refused',
              r'No route to host',
              r'Network is unreachable',
              r'kex_exchange_identification',
          ]

          sel = [ln for ln in data if any(re.search(p, ln, re.I) for p in patterns)]
          if not sel:
              sel = data[:80]

          text = "\n".join(sel)

          # Redact host/user/port and raw IPs.
          if host and port:
              text = text.replace(f'[{host}]:{port}', '<HOST>:<PORT>')
          if user and host:
              text = text.replace(f'{user}@{host}', '<SSH_USER>@<HOST>')
          if user:
              text = text.replace(user, '<SSH_USER>')
          if host:
              text = text.replace(host, '<HOST>')
          if port:
              text = text.replace(f' port {port}', ' port <PORT>')
              text = text.replace(f':{port}', ':<PORT>')

          # IPv4 redaction (best-effort)
          text = re.sub(r'\b\d{1,3}(?:\.\d{1,3}){3}\b', '<IP>', text)
          # IPv6 redaction (best-effort)
          text = re.sub(r'\b(?:[0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}\b', '<IPV6>', text)

          offered_fps = []
          server_hostkey_fps = []
          saw_server_accepts = False
          target_ip = ''
          target_ip_version = 'unknown'
          target_ip_class = 'unknown'

          def classify_ipv4(ip: str) -> str:
              try:
                  parts = [int(x) for x in ip.split('.')]
                  if len(parts) != 4 or any(p < 0 or p > 255 for p in parts):
                      return 'unknown'
                  o1, o2, o3, o4 = parts
                  if o1 == 10:
                      return 'private'
                  if o1 == 127:
                      return 'loopback'
                  if o1 == 0:
                      return 'reserved'
                  if o1 == 169 and o2 == 254:
                      return 'link-local'
                  if o1 == 192 and o2 == 168:
                      return 'private'
                  if o1 == 172 and 16 <= o2 <= 31:
                      return 'private'
                  return 'public'
              except Exception:
                  return 'unknown'

          def classify_ipv6(ip: str) -> str:
              ip_l = ip.lower()
              if ip_l == '::1':
                  return 'loopback'
              if ip_l.startswith('fe80:'):
                  return 'link-local'
              if ip_l.startswith('fc') or ip_l.startswith('fd'):
                  return 'unique-local'
              return 'public-or-global'

          for ln in data:
              if not target_ip and 'Connecting to' in ln:
                  lb = ln.find('[')
                  rb = ln.find(']', lb + 1) if lb != -1 else -1
                  if lb != -1 and rb != -1:
                      target_ip = ln[lb + 1 : rb].strip()
                      if ':' in target_ip:
                          target_ip_version = '6'
                          target_ip_class = classify_ipv6(target_ip)
                      else:
                          target_ip_version = '4'
                          target_ip_class = classify_ipv4(target_ip)
              if 'Offering public key' in ln:
                  m = re.search(r'SHA256:[A-Za-z0-9+/=]+' , ln)
                  if m:
                      offered_fps.append(m.group(0))
              if 'Server host key' in ln:
                  m = re.search(r'SHA256:[A-Za-z0-9+/=]+' , ln)
                  if m:
                      server_hostkey_fps.append(m.group(0))
              if re.search(r'Server accepts key', ln, re.I):
                  saw_server_accepts = True

          if offered_fps:
              print('offered_public_key_fingerprint=' + ','.join(sorted(set(offered_fps))))
          if server_hostkey_fps:
              print('server_host_key_fingerprint=' + ','.join(sorted(set(server_hostkey_fps))))
          print('server_accepts_key=' + ('yes' if saw_server_accepts else 'no'))
          if target_ip:
              print('ssh_target_ip_version=' + target_ip_version)
              print('ssh_target_ip_class=' + target_ip_class)

          print('SSH debug (-vv) sanitized excerpt:')
          print(text)

          if not saw_server_accepts:
              print('')
              print('排障建议（认证失败通常是以下原因之一）：')
              print('1) secrets.CI/SSH_PRIVATE_KEY 对应的公钥未加入服务器的 ~/.ssh/authorized_keys（或加到了别的用户）。')
              print('2) 连接到的不是你以为的那台机器（HOST/DNS/端口转发指向错误，或多台机器复用同一 host key）。')
              print('3) 服务器 sshd 对 root/外网来源做了限制（Match Address / PermitRootLogin / AllowUsers / fail2ban/防火墙）。')
              print('建议在服务器上查看最近 SSH 日志：journalctl -u ssh -S \"30 min ago\" | tail -n 200')
          PY
                rm -f "$SSH_DEBUG_FILE" || true
              fi

              rm -f "$SSH_ERR_FILE" || true
              exit 1
            fi

            rm -f "$SSH_ERR_FILE" || true

      - name: Report deploy status (issue #1)
        if: always()
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          DEPLOYED_SHA: ${{ github.sha }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          STATUS_RAW: ${{ job.status }}
        run: |
          set -uo pipefail

          if [[ -z "${GITHUB_TOKEN:-}" ]]; then
            echo "::warning::GITHUB_TOKEN is missing; skip deploy status report."
            exit 0
          fi

          payload="$(python - <<'PY'
          import json
          import os

          status_raw = os.environ.get('STATUS_RAW', '').strip().lower()
          status = 'success' if status_raw == 'success' else 'failure'

          body = (
              f"deployed_sha: {os.environ['DEPLOYED_SHA']}\n"
              f"run_url: {os.environ['RUN_URL']}\n"
              f"status: {status}"
          )
          print(json.dumps({"body": body}))
          PY
          )"

          http_code="$(
            printf '%s' "$payload" | curl -sS -o /dev/null -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/1/comments" \
              -d @- || echo '000'
          )"

          if [[ "$http_code" != "201" && "$http_code" != "200" ]]; then
            echo "::warning::Failed to post deploy status comment to issue #1 (http_code=$http_code)."
          fi
